if not mods["quality"] then return end

local recycling = require("__quality__/prototypes/recycling")

local recycling_categories = {}

for k, v in pairs(data.raw.furnace.recycler.crafting_categories) do
    recycling_categories[v] = true
end

local function allow_recycling(recipe)
    if recipe.force_auto_recycle then return true end
    if (recipe.auto_recycle == false) or (recipe.auto_recycle_bypass == false) then return false end
    if not recipe.category then recipe.category = "crafting" end
    if not data.raw["recipe-category"][recipe.category] then return false end
    if data.raw["recipe-category"][recipe.category].can_recycle == false then return false end
    return true
end

local function get_canonical_recipe(item)
    --if a canonical recipe is specified, use that. no questions asked.
    if item.canonical_recipe ~= nil then return item.canonical_recipe end

    --if a recipe exists with the exact same name that produces the item, use that.
    if data.raw.recipe[item.name] and data.raw.recipe[item.name].results then
        for k, product in pairs(data.raw.recipe[item.name].results) do
            if product.name == item.name and product.type == "item" then
                return item.name
            end
        end
    end

    --if exactly one valid recipe produces the item with no byproducts, use that.
    local candidate = nil
    for k, recipe in pairs(data.raw.recipe) do
        if recipe.results and #recipe.results == 1 and allow_recycling(recipe) then
            local ok = false
            local solids = 0
            for k2, product in pairs(recipe.results) do --not taking risks if someone uses weird keys for their tables.
                if product.type == "item" then
                    solids = solids + 1
                    if product.name == item.name then
                        ok = true
                    end
                end
            end
            if (solids == 1) and ok then
                if candidate then
                    candidate = nil
                else
                    candidate = recipe.name
                end
            end
        end
    end
    if candidate then return candidate end
    return true
end

--local existing_scrap_recipes = {}
--local final_scrap_recipes = {}

--purge all autogenerated recycling recipes.
for name, recipe in pairs(data.raw.recipe) do
    if (recycling_categories[recipe.category]) and not recipe.bespoke then
        data.raw.recipe[name] = nil
        --existing_scrap_recipes[name] = true
    end

    --sort all bespoke recipe products by probability.
    if (recycling_categories[recipe.category]) and recipe.bespoke then
        local sorted_products = {}
        for k, product in pairs(recipe.results) do
            local placed = false
            product.amount_normalized = product.amount
            if not product.amount_normalized then
                product.amount_normalized = (product.amount_min + product.amount_max) / 2
            end
            for index, comparison in pairs(sorted_products) do
                if ((product.amount_normalized) * (product.probability or 1)) > ((comparison.amount_normalized) * (comparison.probability or 1)) then
                    placed = true
                    table.insert(sorted_products, index, product)
                    break
                end
            end
            if not placed then
                table.insert(sorted_products, product)
            end
        end
        for k, product in pairs(sorted_products) do
            product.amount_normalized = nil
        end
        recipe.results = sorted_products
    end
end

for itemtype, v in pairs(defines.prototypes.item) do
    --log(itemtype)
    if data.raw[itemtype] then
        for k2, item in pairs(data.raw[itemtype]) do
            if not (data.raw.recipe[item.name .. "-recycling"] and data.raw.recipe[item.name .. "-recycling"].bespoke) then
                local canonical_recipe = get_canonical_recipe(item)
                --false = no recycle or bespoke premade recipe
                --true = self-recycle
                --string = recipe name to generate reverse version of, or self-recycle if it fails allow_recycling
                if canonical_recipe and data.raw.recipe[canonical_recipe] then
                    recycling.generate_recycling_recipe(data.raw.recipe[canonical_recipe], allow_recycling)
                end
                if (not data.raw.recipe[item.name .. "-recycling"]) and (not string.find(item.name, "-barrel")) and not canonical_recipe == false then
                    recycling.generate_self_recycling_recipe(item)
                end
                --final_scrap_recipes[item.name .. "-recycling"] = true
            end
        end
    end
end

local bespoke_recipes = {}
local new_recipes = {}

local biggest_result_list = 12

for k, v in pairs(data.raw.recipe) do
    if type(v.bespoke) == "string" and recycling_categories[v.category] then
        if bespoke_recipes[v.bespoke] then
            error("Conflicting bespoke recycling recipes for " .. v.bespoke .. ": " .. v.name .. " and " .. bespoke_recipes[v.bespoke])
        end
        bespoke_recipes[v.bespoke] = v.name
        local new_recipe = table.deepcopy(v)
        new_recipe.name = v.bespoke .. "-recycling"
        new_recipe.bespoke = nil
        table.insert(new_recipes, new_recipe)
    end

    if recycling_categories[v.category] and v.results and (#v.results > biggest_result_list) then
        biggest_result_list = #v.results
    end
end

for k, v in pairs(bespoke_recipes) do
    data.raw.recipe[v] = nil
end

data.raw.furnace.recycler.result_inventory_size = biggest_result_list
if mods["Age-of-Production"] then
    data.raw.furnace["aop-salvager"].result_inventory_size = biggest_result_list
end

if #new_recipes > 0 then
    data:extend(new_recipes)
end

--for k, v in pairs(existing_scrap_recipes) do
    --if not final_scrap_recipes[k] then
        --log("Recycling recipe removed: " .. k)
    --end
--end

--for k, v in pairs(final_scrap_recipes) do
    --if not existing_scrap_recipes[k] then
        --log("Recycling recipe added: " .. k)
    --end
--end